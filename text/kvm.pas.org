#+title: kvm : keyboard/video/mouse support for virtual consoles
#+author: Michal J Wallace
#+date: <2013-06-08 Sat>

* Goals
This module implements an enhanced terminal device with support for unicode and a 256 color palette.

* =ITerm= : abstract screen interface

A screen tracks a cursor position, bounds, color.

#+name: ITerm
#+begin_src pascal
  type ITerm = interface
    function  Width : word;
    function  Height: word;
    function  MaxX  : word; deprecated;
    function  MaxY  : word; deprecated;
    function  XMax  : word;
    function  YMax  : word;
    function  WhereX: word;
    function  WhereY: word;
    procedure ClrScr;
    procedure ClrEol;
    procedure Fg( c : byte );
    procedure Bg( c : byte );
    procedure Emit( wc : widechar );
    procedure Emit( s : TStr );
    procedure GotoXY( x, y : word );
    procedure InsLine;
    procedure DelLine;
    procedure SetTextAttr( value : word );
    function  GetTextAttr : word;
    property  TextAttr : word read GetTextAttr write SetTextAttr;
    procedure ShowCursor;
    procedure HideCursor;
  end;
#+end_src

* Data Types
** TTextAttr
For our text attributes, we're going to use 256 colors. This strikes a good balance between storage space and aesthetics. There's really not much need for more colors than this when we're talking about a fixed-width text display.

#+name: TTextAttr
#+begin_src pascal
  type TTextAttr = record
      bg : byte;
      fg : byte;
    end;
#+end_src

** TTermCell

A terminal cell combines a text attribute with a 16-bit WideChar.

#+name: TTermCell
#+begin_src pascal
  type TTermCell = record
      ch   : widechar;
      attr : TTextAttr;
    end;
#+end_src

** TTermGrid

A terminal's display buffer is essentially a grid of such cells. I'm using my [[https://github.com/tangentstorm/xpl/blob/master/code/grids.pas][generic =GGrid2d= class]] here to avoid duplicating code.

#+name: TTermGrid
#+begin_src pascal
  type TTermGrid = class (specialize GGrid2d<TTermCell>)
    private
      function GetAttr( const x, y : word ) : TTextAttr;
      function GetChar( const x, y : word ) : WideChar;
      procedure SetAttr( const x, y : word; const value : TTextAttr );
      procedure SetChar( const x, y : word; const value : WideChar );
    public
      property attrs[ x, y : word ] : TTextAttr read GetAttr write SetAttr;
      property chars[ x, y : word ] : WideChar read GetChar write SetChar;
    end;
#+end_src

#+name: @kvm:impl
#+begin_src pascal

  function TTermGrid.GetAttr( const x, y : word ) : TTextAttr;
    begin
      result.fg := self[ x, y ].attr.fg;
      result.bg := self[ x, y ].attr.bg;
    end;

  procedure TTermGrid.SetAttr( const x, y  : word;
                               const value : TTextAttr );
    begin
      with _data[ xyToI( x, y ) ].attr do
        begin
          bg := value.bg;
          fg := value.fg;
        end
    end;

  function TTermGrid.GetChar( const x, y : word ) : WideChar;
    begin
      result := self[ x, y ].ch;
    end;

  procedure TTermGrid.SetChar( const x, y  : word;
                               const value : WideChar );
    begin
      _data[ xyToI( x, y ) ].ch := value;
    end;

#+end_src

** TPoint

#+name: TPoint
#+begin_src pascal
  type TPoint = class
    x, y : cardinal;
  end;
#+end_src

** TRect
#+name: TRect
#+begin_src pascal
  type TRect = class
    x, y : cardinal;
    w, h : cardinal;
  end;
#+end_src

* =TGridTerm=
This is a contrcete implementation of ITerm.

#+name: TGridTerm
#+begin_src pascal
  type TGridTerm = class  (TInterfacedObject, ITerm) // (TAbstractTerminal)
    public
      <<ITerm-Members>>
    private
      attr : TTextAttr;
      _curs : TPoint;
      _grid : TTermGrid;
    public
      constructor Create( w, h : word );
      destructor Destroy; override;
      function  Cursor : TPoint;
      function GetCell( x, y : word ) : TTermCell;
      procedure PutCell( x, y : word; cell : TTermCell );
      property grid : TTermGrid read _grid;
      property cells[ x, y : word ] : TTermCell
        read GetCell write PutCell; default;
    end;
#+end_src

** Implementation

#+name: @kvm:impl
#+begin_src pascal

  constructor TGridTerm.Create( w, h : word );
    begin
      inherited create;
      _grid := TTermGrid.Create( w, h );
      _curs := TPoint.Create; _curs.x := 0; _curs.y := 0;
    end;

  destructor TGridTerm.Destroy;
    begin;
      _grid.Free;
      inherited destroy;
    end;

  function  TGridTerm.Width  : word; begin result := grid.w     end;
  function  TGridTerm.Height : word; begin result := grid.h     end;
  function  TGridTerm.MaxX   : word; begin result := xMax       end;
  function  TGridTerm.MaxY   : word; begin result := yMax       end;
  function  TGridTerm.XMax   : word; begin result := width - 1  end;
  function  TGridTerm.YMax   : word; begin result := height - 1 end;
  function  TGridTerm.WhereX : word; begin result := _curs.x    end;
  function  TGridTerm.WhereY : word; begin result := _curs.y    end;

  function  TGridTerm.GetTextAttr : word;
    begin
      result := word(attr)
    end;

  procedure TGridTerm.SetTextAttr( value : word );
    begin
      attr := TTextAttr(value)
    end;

  procedure TGridTerm.Fg( color : byte );
    begin
      attr.fg := color
    end;

  procedure TGridTerm.Bg( color : byte );
    begin
      attr.bg := color
    end;

  procedure TGridTerm.ClrScr;
    var cell : TTermCell;
    begin
      cell.ch := ' ';
      cell.attr := attr;
      _grid.fill(cell);
      gotoxy(0,0);
    end;

  procedure TGridTerm.ClrEol;
    begin
      raise Exception.Create('TODO: TGridTerm.ClrEol');
    end;

  procedure TGridTerm.GotoXY( x, y : word );
    begin
      _curs.x := x;
      _curs.y := y;
    end;

  procedure TGridTerm.Emit( wc : widechar );
    var cell : TTermCell;
    begin
      cell.ch := wc;
      cell.attr := attr;
      _grid[_curs.x, _curs.y] := cell;
      inc(_curs.x);
      if _curs.x >= self.width then
        begin
          _curs.x := 0;
          inc(_curs.y);
          // todo: scroll
        end;
    end;

  procedure TGridTerm.Emit( s : TStr );
    var ch : widechar;
    begin
      for ch in s do Emit(ch);
    end;

  procedure TGridTerm.InsLine;
    begin
      raise Exception.Create('TODO: TGridTerm.InsLine');
    end;

  procedure TGridTerm.DelLine;
    begin
      raise Exception.Create('TODO: TGridTerm.DelLine');
    end;

  function TGridTerm.Cursor : TPoint;
    begin
      result := _curs
    end;

  procedure TGridTerm.ShowCursor;
    begin
      ok
    end;

  procedure TGridTerm.HideCursor;
    begin
      ok
    end;

  function TGridTerm.GetCell( x, y : word ) : TTermCell;
    begin
      result := _grid[x,y]
    end;

  procedure TGridTerm.PutCell( x, y : word; cell : TTermCell );
    begin
      _grid[x,y] := cell;
    end;

#+end_src

* =TAnsiTerm=
#+name: TAnsiTerm
#+begin_src pascal
  type TAnsiTerm = class (TInterfacedObject, ITerm)
    public
      <<ITerm-Members>>
    private
      attr : word;
    public
      constructor Create;
      procedure ResetColor;
    end;
#+end_src

#+name: @kvm:impl
#+begin_src pascal

  constructor TAnsiTerm.Create;
    begin
      attr := $0007
    end;

  { TODO: find a way to get this data without the baggage incurred by
    crt or video modules (breaking keyboard input or clearing the screen  }

  function  TAnsiTerm.Width  : word; begin result := terminal.w end;
  function  TAnsiTerm.Height : word; begin result := terminal.h end;
  function  TAnsiTerm.MaxX   : word; begin result := xMax end;
  function  TAnsiTerm.MaxY   : word; begin result := yMax end;
  function  TAnsiTerm.XMax   : word; begin result := width - 1  end;
  function  TAnsiTerm.YMax   : word; begin result := height - 1 end;

  function  TAnsiTerm.WhereX : word;
    var bx, by : byte;
    begin
      terminal.getxy(bx, by);
      result := bx;
    end;

  function  TAnsiTerm.WhereY : word;
    var bx, by : byte;
    begin
      terminal.getxy(bx, by);
      result := by;
    end;

  function  TAnsiTerm.GetTextAttr : word;
    begin
      result := attr;
    end;

  procedure TAnsiTerm.SetTextAttr( value : word );
    begin
      Fg(lo(value));
      Bg(hi(value));
    end;

  procedure TAnsiTerm.Fg( color : byte );
    begin
      attr := hi(attr) shl 8 + color;
      { xterm 256-color extensions }
      write( stdout, #27, '[38;5;', color , 'm' )
    end;

  procedure TAnsiTerm.Bg( color : byte );
    begin
      attr := color shl 8 + lo(attr);
      { xterm 256-color extensions }
      write( stdout, #27, '[48;5;', color , 'm' )
    end;

  procedure TAnsiTerm.ClrScr;
    begin
      write( stdout, #27, '[H', #27, '[J' )
    end;

  procedure TAnsiTerm.ClrEol;
    var curx, cury, i : byte;
    begin
      terminal.getxy( curx, cury );
      for i := curx to xMax do write(stdout, ' ');
      gotoxy( curx, cury );
    end;

  procedure TAnsiTerm.GotoXY( x, y : word );
    begin
      write(stdout, #27, '[', y + 1, ';', x + 1, 'H' )
    end;

  procedure TAnsiTerm.Emit( wc : widechar );
    begin
      write(stdout, utf8encode( wc ))
    end;
  procedure TAnsiTerm.Emit( s : TStr );
    begin
      write(stdout, utf8encode( s ))
    end;

  { TODO }
  procedure TAnsiTerm.InsLine;
    begin
    end;

  procedure TAnsiTerm.DelLine;
    begin
    end;

  procedure TAnsiTerm.ResetColor;
    begin
      write(stdout, #27, '[0m' )
    end;

  procedure TAnsiTerm.ShowCursor; // !! xterm / dec terminals
    begin
      write(stdout, #27, '[?25h');
    end;

  procedure TAnsiTerm.HideCursor; // !! xterm / dec terminals
    begin
      write(stdout, #27, '[?25l');
    end;

#+end_src

* =TTermProxy= : generic base class for decorators
** interface

#+name: TTermProxy
#+BEGIN_SRC pascal
  type TTermProxy = class  (TInterfacedObject, ITerm)
    protected
      _term : ITerm;
    public
      constructor Create( term : ITerm);
      function  Width : word; virtual;
      function  Height: word; virtual;
      function  WhereX : word; virtual;
      function  WhereY : word; virtual;
      procedure ClrScr; virtual;
      procedure ClrEol; virtual;
      procedure Fg( color : byte ); virtual;
      procedure Bg( color : byte ); virtual;
      procedure Emit( wc : widechar ); virtual;
      procedure Emit( s : TStr ); virtual;
      procedure GotoXY( x, y : word ); virtual;
      procedure InsLine; virtual;
      procedure DelLine; virtual;
      procedure SetTextAttr( value : word ); virtual;
      function  GetTextAttr : word; virtual;
      procedure ShowCursor; virtual;
      procedure HideCursor; virtual;
      property  TextAttr : word read GetTextAttr write SetTextAttr;
      function  MaxX  : word; deprecated;
      function  MaxY  : word; deprecated;
      function  XMax  : word; virtual;
      function  YMax  : word; virtual;
    end;
#+END_SRC

** implementation
#+name: @kvm:impl
#+BEGIN_SRC pascal

  constructor TTermProxy.Create( term : ITerm );
    begin
      inherited Create;
      _term := term;
    end;

  function  TTermProxy.Width  : word; begin result := _term.Width end;
  function  TTermProxy.Height : word; begin result := _term.Height end;
  function  TTermProxy.WhereX : word; begin result := _term.WhereX end;
  function  TTermProxy.WhereY : word; begin result := _term.WhereY end;
  function  TTermProxy.MaxX   : word; begin result := self.xMax end;
  function  TTermProxy.MaxY   : word; begin result := self.yMax end;
  function  TTermProxy.xMax   : word; begin result := self.width-1 end;
  function  TTermProxy.yMax   : word; begin result := self.height-1 end;


  procedure TTermProxy.ClrScr; begin _term.ClrScr end;
  procedure TTermProxy.ClrEol; begin _term.ClrEol end;

  procedure TTermProxy.Fg( color : byte );    begin _term.Fg( color ) end;
  procedure TTermProxy.Bg( color : byte );    begin _term.Bg( color ) end;

  procedure TTermProxy.Emit( wc : widechar ); begin _term.Emit( wc ) end;
  procedure TTermProxy.Emit( s : TStr ); begin _term.Emit( s ) end;
  procedure TTermProxy.GotoXY( x, y : word ); begin _term.GotoXY( x, y ) end;

  procedure TTermProxy.InsLine; begin _term.InsLine end;
  procedure TTermProxy.DelLine; begin _term.DelLine end;

  procedure TTermProxy.ShowCursor; begin _term.ShowCursor end;
  procedure TTermProxy.HideCursor; begin _term.HideCursor end;

  procedure TTermProxy.SetTextAttr( value : word );
     begin
       _term.TextAttr := value
     end;
  function  TTermProxy.GetTextAttr : word;
    begin
      result := _term.TextAttr
    end;

#+END_SRC

* =TSubTerm= : a window inside a terminal
** interface
#+name: TSubTerm
#+BEGIN_SRC pascal
  type
    TSubTerm = class (TTermProxy)
      protected
        _x, _y, _w, _h : word;
      public
        constructor Create(term : ITerm; x, y, w, h : word );
        function  Width : word; override;
        function  Height: word; override;
        function  WhereX : word; override;
        function  WhereY : word; override;
        procedure ClrScr; override;
        procedure ClrEol; override;
        procedure GotoXY( x, y : word ); override;
        procedure InsLine; override;
        procedure DelLine; override;
      end;
#+END_SRC

** implementation
#+name: @kvm:impl
#+BEGIN_SRC pascal

    constructor TSubTerm.Create(term : ITerm; x, y, w, h : word );
      begin
        inherited Create(term);
        _x := x;
        _y := y;
        _w := w;
        _h := h;
      end;

    function  TSubTerm.Width : word;
      begin
        result := _w
      end;

    function  TSubTerm.Height: word;
      begin
        result := _h
      end;

    function  TSubTerm.WhereX : word;
      begin
        result := _term.WhereX - _x
      end;

    function  TSubTerm.WhereY : word;
      begin
        result := _term.WhereY - _y
      end;

    procedure TSubTerm.ClrScr;
      var y : word; i : integer;
      begin
        for y := 0 to yMax do
          begin
            gotoxy(0, y);
            for i := 1 to self.width do emit(' ');
          end;
        gotoxy(0, 0);
      end;

    procedure TSubTerm.ClrEol;
      var curx, cury, i : word;
      begin
        curx := self.WhereX;
        cury := self.WhereY;
        for i := curx to xMax do _term.emit(' ');
        self.gotoxy( curx, cury );
      end;

    procedure TSubTerm.GotoXY( x, y : word );
      begin
        _term.GotoXY( x + _x, y + _y );
      end;

    procedure TSubTerm.InsLine;
      begin
        raise Exception.Create('TSubTerm.InsLine not yet implemented. :/');
      end;

    procedure TSubTerm.DelLine;
      begin
        raise Exception.Create('TSubTerm.DelLine not yet implemented. :/');
      end;

#+END_SRC

* =TVideoTerm= : uses free pascal's =video= unit
#+name: TVideoTerm
#+begin_src pascal
  type TVideoTerm = class (TInterfacedObject, ITerm)
    public
      <<ITerm-Members>>
    private
      attr : word;
    public
      constructor Create;
      procedure ResetColor;
    end;
#+end_src

#+name: @kvm:impl
#+begin_src pascal

  constructor TVideoTerm.Create;
    begin
      attr := $0007
    end;

  { TODO: find a way to get this data without the baggage incurred by
    crt or video modules (breaking keyboard input or clearing the screen  }

  function  TVideoTerm.Width  : word; begin result := terminal.w end;
  function  TVideoTerm.Height : word; begin result := terminal.h end;
  function  TVideoTerm.MaxX   : word; begin result := xMax end;
  function  TVideoTerm.MaxY   : word; begin result := yMax end;
  function  TVideoTerm.XMax   : word; begin result := width - 1  end;
  function  TVideoTerm.YMax   : word; begin result := height - 1 end;

  function  TVideoTerm.WhereX : word;
    var bx, by : byte;
    begin
      terminal.getxy(bx, by);
      result := bx;
    end;

  function  TVideoTerm.WhereY : word;
    var bx, by : byte;
    begin
      terminal.getxy(bx, by);
      result := by;
    end;

  function  TVideoTerm.GetTextAttr : word;
    begin
      result := attr;
    end;

  procedure TVideoTerm.SetTextAttr( value : word );
    begin
      Fg(lo(value));
      Bg(hi(value));
    end;

  procedure TVideoTerm.Fg( color : byte );
    begin
    end;

  procedure TVideoTerm.Bg( color : byte );
    begin
    end;

  procedure TVideoTerm.ClrScr;
    begin
    end;

  procedure TVideoTerm.ClrEol;
    var curx, cury, i : byte;
    begin
    end;

  procedure TVideoTerm.GotoXY( x, y : word );
    begin
    end;

  procedure TVideoTerm.Emit( wc : widechar );
    begin
      { TODO: handle escaped characters }
      write( wc )
    end;
  procedure TVideoTerm.Emit( s : TStr );
    var ch : widechar;
    begin
      for ch in s do emit(ch);
    end;

  { TODO }
  procedure TVideoTerm.InsLine;
    begin
    end;

  procedure TVideoTerm.DelLine;
    begin
    end;

  procedure TVideoTerm.ResetColor;
    begin
    end;

  procedure TVideoTerm.ShowCursor; // !! xterm / dec terminals
    begin
    end;

  procedure TVideoTerm.HideCursor; // !! xterm / dec terminals
    begin
    end;

#+end_src


* char mnemonics for ansi colors.

#+name: extras
#+begin_src pascal
  procedure fg( c : char );
  procedure bg( c : char );
#+end_src

#+name: @kvm:impl
#+begin_src pascal

  procedure bg( c :  char );
    var i : byte;
    begin
      i := pos( c, 'krgybmcwKRGYBMCW' );
      if i > 0 then bg( i - 1  );
    end;

  procedure fg( c :  char );
    var i : byte;
    begin
      i := pos( c, 'krgybmcwKRGYBMCW' );
      if i > 0 then fg( i - 1  );
    end;

#+end_src

* text driver to redirect =write= and =writeln=
#+name: textdriver
#+begin_src pascal

function KvmWrite(var f: textrec): integer;
  var
    i : integer ; s: string;
  begin
    if f.bufpos > 0 then
    begin
      setlength(s, f.bufpos);
      move(f.buffer, s[1], f.bufpos);
      kvm.emit(s);
    end;
    f.bufpos := 0;
    Result := 0;
  end;

function KvmClose(var txt: TTextRec): integer;
  begin
    Result := 0;
  end;

function KvmOpen(var txt: TTextRec): integer;
  begin
    case txt.mode of
      fmOutput:
      begin
        txt.inOutFunc := @KvmWrite;
        txt.flushFunc := @KvmWrite;
      end
      else // todo : error;
    end;
    Result := 0;
  end;

// http://docwiki.embarcadero.com/RADStudio/XE5/en/Standard_Routines_and_Input-Output
procedure AssignKvm(var txt: Text);
  begin
    Assign(txt, '');
    with TTextRec(txt) do
    begin
      mode := fmClosed;
      openFunc := @KvmOpen;
      closeFunc := @KvmClose;
    end;
  end;
#+end_src


* Unit Life cycle.

There are basically two steps to deal with:

#+name: lifecycle
#+begin_src pascal
  initialization
    <<redirect-io>>
    <<create-term-obj>>
  finalization
    { work is destroyed automatically by reference count }
#+end_src

First, we want to redirect the =Output= file, so that calls to =Write= and =WriteLn= are sent through =KvmWrite=. Since we may still need to access the standard output (especially in the case of =ANSITerm=), we'll also create a new file descriptor.

#+name: redirect-io
#+begin_src pascal
  Assign(stdout,''); Rewrite(stdout);
  AssignKVM(output); Rewrite(output);
#+end_src

The second step is simply to create a new =ITerm= instance and assign the =work= variable.

#+name: create-term-obj
#+begin_src pascal
  {$IFDEF UNIX}
    work :={$IFDEF VIDEOKVM}TVideoTerm.Create
           {$ELSE}TAnsiTerm.Create{$ENDIF};
    work.GotoXY( terminal.startX, terminal.startY );
  {$ELSE}
    work := TGridTerm.Create(64, 16);
  {$ENDIF}
#+end_src

* Legacy interface : =CRT.pas=

CRT was the original console library for turbo pascal. It uses 1-based cordinates, and is limited to 16 colors.

** interface
#+begin_src pascal :tangle "../code/ucrt.pas" :noweb tangle



  { --- warning!! generated file. edit ../text/kvm.pas.org instead!! --- }


  {$mode objfpc}
  unit crt;
  interface uses kvm;

  { helpers }
  function crt_get_textattr : byte;
  procedure crt_set_textattr( value : byte );

  { window / cursor managament }
  var WindMaxX, WindMaxY, WindMinX, WindMinY : byte;
  procedure GotoXY( x, y : word );
  function  WhereX : byte;
  function  WhereY : byte;
  procedure Window( x1, y1, x2, y2 : Byte );
  procedure ClrEol;
  procedure ClrScr;
  procedure DelLine; { delete line at cursor }
  procedure InsLine; { insert line at cursor }

  { color }
  procedure TextColor( c : byte );
  procedure TextBackground( c : byte );
  procedure HighVideo;
  procedure LowVideo;
  procedure NormVideo; { restores color from startup }
  property TextAttr : byte
    read  crt_get_textattr
    write crt_set_textattr;

  { interaction }
  function  KeyPressed : boolean;
  function  ReadKey : char;
  procedure Delay;
  procedure Sound( hz : word );
  procedure NoSound;
  { TODO:
  property CheckBreak : boolean }

  implementation
    <<@crt:impl>>
  end.
#+end_src

** implementation
*** the =TextAttr= property

#+name: @crt:impl
#+begin_src pascal
  var _textattr : kvm.TTextAttr;
  type TCrtColor  = $0 .. $f;

  procedure crt_set_textattr( value : byte );
  begin
    _textattr.bg := hi( value );
    _textattr.fg := lo( value );
  end;

  function crt_get_textattr : byte;
  begin
    result := (_textattr.bg shl 8) + _textattr.fg;
  end;

  procedure TextColor( c : byte );
  begin
    _textattr.fg := TCrtColor( c );
  end;

  procedure TextBackground( c : byte );
  begin
    _textattr.bg := TCrtColor( c );
  end;

#+end_src

*** Cursor control
#+name: @crt:impl
#+begin_src pascal

  var _x, _y : byte;
  procedure GotoXY( x, y : word );
  begin
    _x := x;
    _y := y;
  end;

  function WhereX:byte;
    begin
      result := _X;
    end;

  function WhereY:byte;
    begin
      result := _y;
    end;


#+end_src

*** TODO finish implementing these
#+name: @crt:impl
#+begin_src pascal

  procedure window(x1,y1,x2,y2:byte);
    begin
      // TODO: i don't think this is right behavior
      windMinX := x1;
      windMinY := y1;
      windMaxX := x2;
      windMaxY := y2;
    end;

  procedure clreol;
    begin
    end;

  procedure clrscr;
    begin
    end;

  procedure delline; begin end;
  procedure insline; begin end;
  procedure highvideo; begin end;
  procedure lowvideo; begin end;
  procedure normvideo; begin end;
  function keypressed:boolean; begin result := false end;
  function readkey:char; begin result := #255 end;
  procedure delay; begin end;
  procedure sound( hz : word); begin end;
  procedure nosound; begin end;

#+end_src

* APPENDIX Convenience Routines

In general, you're only going to work with one screen at a time, so it's convenient to have a set of routines that deal with whatever the current screen happens to be at the moment.

** interface
These follow the ITerm interface exactly.

#+name: ITerm-Members
#+begin_src  pascal
  function  Width : word;
  function  Height: word;
  function  MaxX  : word; deprecated;
  function  MaxY  : word; deprecated;
  function  XMax  : word;
  function  YMax  : word;
  function  WhereX : word;
  function  WhereY : word;
  procedure ClrScr;
  procedure ClrEol;
  procedure Fg( color : byte );
  procedure Bg( color : byte );
  procedure Emit( wc : widechar ); {$IFNDEF unitscope}virtual;{$ENDIF}
  procedure Emit( s : TStr ); {$IFNDEF unitscope}virtual;{$ENDIF}
  procedure GotoXY( x, y : word );
  procedure InsLine;
  procedure DelLine;
  procedure SetTextAttr( value : word );
  function  GetTextAttr : word;
  property  TextAttr : word read GetTextAttr write SetTextAttr;
  procedure ShowCursor;
  procedure HideCursor;
#+end_src

** implementation

Since they just delegate to an =ITerm=, the implementation is trivial.

#+name: @kvm:impl
#+begin_src pascal
  function  Width  : word; begin result := work.Width end;
  function  Height : word; begin result := work.Height end;
  function  MaxX   : word; begin result := work.xMax end;
  function  MaxY   : word; begin result := work.yMax end;
  function  XMax   : word; begin result := work.xMax end;
  function  YMax   : word; begin result := work.yMax end;
  function  WhereX : word; begin result := work.WhereX end;
  function  WhereY : word; begin result := work.WhereY end;

  procedure ClrScr; begin work.ClrScr end;
  procedure ClrEol; begin work.ClrEol end;

  procedure Fg( color : byte );    begin work.Fg( color ) end;
  procedure Bg( color : byte );    begin work.Bg( color ) end;

  procedure Emit( wc : widechar ); begin work.Emit( wc ) end;
  procedure Emit( s : TStr ); begin work.Emit( s ) end;
  procedure GotoXY( x, y : word ); begin work.GotoXY( x, y ) end;

  procedure InsLine; begin work.InsLine end;
  procedure DelLine; begin work.DelLine end;

  procedure ShowCursor; begin work.ShowCursor end;
  procedure HideCursor; begin work.HideCursor end;

  procedure SetTextAttr( value : word );
    begin work.TextAttr := value end;
  function  GetTextAttr : word;
    begin result := work.TextAttr end;
#+end_src

** Screens
#+begin_src pascal
  { these two are a bit trickier }
  function TScreen.GetTextAttr : word;
    begin
      result := ( work._fg shl 8 ) + work._bg;
    end;

  procedure TScreen.SetTextAttr( value : word );
    begin
      work._fg := value and $0f;
      work._bg := (value and $f00) shr 8;
      fg( work._fg );
      bg( work._bg );
    end;
#+end_src

* OUTPUT =kvm.pas=
#+begin_src pascal :tangle "../code/kvm.pas" :noweb tangle


  { --- warning!! generated file. edit ../text/kvm.pas.org instead!! --- }


  {$mode objfpc}{$i xpc.inc}
  unit kvm;
  interface uses xpc, ugrid2d, sysutils,
    {$ifdef VIDEOKVM}video
    {$else}terminal
    {$endif}
    ;

  var stdout : text;

    <<ITerm>>
    {$DEFINE unitscope}
    <<ITerm-Members>>
    {$UNDEF unitscope}

    <<TTextAttr>>
    <<TTermCell>>
    <<TTermGrid>>
    <<TPoint>>
    <<TRect>>
    <<TGridTerm>>
    <<TAnsiTerm>>
    <<TVideoTerm>>
    <<TTermProxy>>
    <<TSubTerm>>

    <<extras>>
  var work : ITerm;

  implementation
    <<@kvm:impl>>
    <<textdriver>>
  <<lifecycle>>
  end.
#+end_src

* COMMENT
** TODO mouse support
#+name @kvm:inter
#+begin_src pascal
function hasmouse : boolean;
function mx : int32;
function my : int32;
function mb : set32;
#+end_src

#+name @kvm:impl
#+begin_src pascal
{  mouse routines are just stubs at the moment }

function hasmouse : boolean;
begin
  result := false;
end; { hasmouse }

function mx : int32;
begin
  result := 0;
end; { mx }

function my : int32;
begin
  result := 0;
end; { my }

function mb : set32;
begin
  result := [];
end; { mbtn }
#+end_src

** TODO bitmap fonts
#+begin_src pascal

type
{  this should probably get moved into its own class? }
type
  vector2d = record
	       case kind : ( asize, apoint, avec2d ) of
		 asize	: ( w, h : int32 );
		 apoint	: ( x, y : int32 );
		 avec2d	: ( v : array[ 0 .. 1 ] of int32 );
	     end;

  glyph	  = record
	      codepoint	: int32;
	      w, h	: int32;
	    end;

  bmpfont = record
	      size   : vector2d;
	      glyphs : array of glyph;
	    end;


#+end_src

** TODO 16-color ansi codes
#+begin_src pascal
  procedure ansi_fg( i : byte );
    begin
      if i < 8 then write(stdout, #27, '[0;3', i , 'm' )           // ansi dim
      else if i < 17 then write(stdout, #27, '[01;3', i-8 , 'm' ); // ansi bold
      // else do nothing
    end; { ansi_fg }

  {
  procedure ansi_bg( i : byte );
    begin
      if i < 8 then write( #27, '[0;3', i , 'm' )           // ansi dim
      else if i < 17 then write( #27, '[01;3', i-8 , 'm' ); // ansi bold
      // else do nothing
    end; }


#+end_src

** TODO bitmapped fonts

#+begin_src pascal
  procedure setfont( font :  bmpfont );
#+end_src

#+begin_src pascal
  procedure setfont( font : bmpfont );
    begin
    end;
#+end_src

** TODO canvas
#+begin_src pascal
  interface

    type
      color   = record
                  case separate : boolean of
                    true  : ( r, g, b, a : byte );
                    false : ( c : int32 );
                end;

      surface = record
                  w, h : int32;
                  data : array of int32;
                end;

      function hascanvas : boolean;
      var canvas : surface;
      var term : surface;

  implementation

      function HasCanvas : boolean;
        begin
          result := false;
        end; { HasCanvas }

#+end_src

** TODO future Goals?
| device           | in | out |                          |
|------------------+----+-----+--------------------------|
| keyboard         | x  |     |                          |
| mouse            | x  |     |                          |
| touch            | x  |     |                          |
| gamepad          | x  | ?   | maybe output for rumble? |
| audio            | x  | x   | telephony                |
| midi             | x  | x   |                          |
| network          | x  | x   |                          |
| display:text     |    | x   |                          |
| display:graphics |    | x   |                          |
